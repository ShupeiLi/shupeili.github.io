---
layout: post
title: "复习日志：计算机组成原理"
categories: computer_systems
tags: [computer_systems, 国企]
math: true

---
## 计算机系统基础

### 历史

- 1946 年 2 月，在美国诞生了世界上第一台电子数字计算机，它的名字是 ENIAC (The Electronic Numerical Integrator and Computer)。

### 大端/小端模式

数据在存储器中按照字节存放时，在大端模式下，数据的高位保存在存储器的低地址端，低位保存在存储器的高地址端（与我们的阅读书写习惯一致）；在小端模式下，数据的低位保存在存储器的低地址端，高位保存在存储器的高地址端。

### 数的表示

- 补码
	- 计算机内部的定点数大多以补码表示。
		- 举例：-0.1010 是一个负数，它的原码、反码、补码分别是 1.1010、1.0101、1.0110。在计算机中该数一般表示为 1.0110。
	- 补码加减法运算中，符号位和数值位一起参加运算。
	- 补码的减法运算可以转化为加法来实现。
	- 定点数的补码加减法中，参与运算的两个操作数都用补码表示，数值位与符号位一同参加运算，减某数采用加其负数的补码的方式替代。
	- 补码表示法推论：无论 $X$ 是正数还是负数，由 $$[X]_{\text{补码}}$$ 求 $$[-X]_{\text{补码}}$$ 的方法都是将 $$[X]_{\text{补码}}$$ 连同符号位的每一位取反，然后末位加 1。
	- $n + 1$ 位的定点小数，其补码表示范围是：$-1 \leq x \leq 1 - 2^{-n}$。
- 原码一位乘法：符号位与数值位是分开进行计算的。运算结果的数值部分是乘数与被乘数数值位的乘积，符号是乘数与被乘数符号位的异或。数值位相乘时，当乘数某位为 1 时，将被乘数绝对值与原部分积相加后，右移一位。
- 并行乘除法运算器通过牺牲硬件的代价来换取运算速度的提高。
- 移码常用来表示浮点数的阶码，其等于补码的符号位取反。
- 计算机在进行浮点数的加减运算之前先进行对阶操作，若 x 的阶码大于 y 的阶码，则应将 y 的阶码扩大至与 x 的阶码相同，且使 y 的尾数部分进行算术右移。

#### 汉字编码

- 内码：用于计算机内部存储和处理汉字的编码形式，是汉字的字符编码。内码主要表示汉字的编码值，用于文本处理。
	- 编码方式：汉字的内码通常基于国际通用的字符编码方案（如 GB2312、GBK、Unicode 等）。
	- 表示单位：每个汉字通常占用 2 字节或更多字节。
		- 在 GB2312 标准中，汉字的编码范围为 A1A1 到 FEFE。
		- 在 GBK 和 Unicode 中，编码范围更大，支持更多汉字。
	- 用途：主要用于文本编辑、存储和传输。
- 字模码：字模码是用于显示或打印汉字的点阵数据，即汉字的形状信息（字形数据）。字模码与显示设备相关。
	- 编码方式：字模码用点阵表示汉字，具体到每个像素点的亮灭状态。
	    - 点阵大小常见为 $16 \times 16$、$24 \times 24$、$32 \times 32$ 等。
	    - 每个点阵中的点用二进制表示，0 表示该点不亮，1 表示该点亮。
	- 存储方式：将点阵数据以字节形式存储，每行或每列一字节。
	- 用途：用于字体渲染，生成汉字的可视化效果。
- 例题：如果某汉字使用 24 $\times$ 24 位点阵码表示，则该汉字内码占 2 个字节，字模码占 72 个字节。
	- GB2312-80 规定，每个汉字、图形符号都用两个字节表示。汉字字形码又叫汉字字模码或者汉字输出码，是指确定一个汉字字形点阵的代码。点阵越大，输出汉字的质量就越高，每个汉字所占的字节数也就越高。一个字节等于 8 位二进制数，所以 24 $\times$ 24 位点阵码可以表示 $24 \times 24 \div 8=72$ 个字节，即字模码占 72 个字节。

### IEEE 754 浮点数

将整数转换为 IEEE 754 浮点数，需要理解 IEEE 754 标准对浮点数的表示方法。IEEE 754 标准规定了 单精度（32 位）和 双精度（64 位）浮点数的格式。下面以 单精度浮点数（32 位）为例，介绍如何将整数转换为 IEEE 754 浮点数。

#### IEEE 754 单精度浮点数结构

IEEE 754 单精度浮点数总共占 32 位，结构如下：

```assembly
1位符号位 | 8位指数位 | 23位尾数位
```

- 符号位（S）：1 位，表示数值的符号。0 表示正数，1 表示负数。
- 指数位（E）：8 位，也叫做阶码，用于表示浮点数的指数。IEEE 754 采用的是 偏移量表示法（bias），单精度的偏移量是 127。
- 尾数位（M）：23 位，用于表示数字的有效部分。由于是标准化形式，尾数通常表示为 1.XXXX，尾数位不包含前导的 1。

#### 步骤

假设你需要将整数 $N$ 转换为 IEEE 754 单精度浮点数，下面是转换的步骤：
1. 判断符号位
	- 如果 $N \geq 0$，符号位为 0。
	- 如果 $N < 0$，符号位为 1。
2. 将整数转换为二进制：将整数 $N$ 转换为二进制表示。如果是负数，先将其绝对值转换为二进制，然后在最后设置符号位为 1。
3. 标准化二进制表示：标准化表示是将二进制数表示为形如 $1.xxxx \times 2^e$ 的形式，其中 $1.xxxx$ 为二进制小数部分，$e$ 为相应的指数。
	- 对于正整数，二进制表示通常是以 1 开头，直接表示为 $1.xxxx \times 2^e$。
	- 对于负整数，按相同规则处理其绝对值，然后设置符号位。
4. 计算指数位：指数位 $E$ 是二进制指数 $e$ 加上偏移量 127（对于单精度来说）。即：$E = e + 127$ ，将这个指数转化为 8 位二进制表示。
5. 计算尾数位：尾数部分是标准化二进制小数部分的后面 23 位。由于前面的 1 在 IEEE 754 格式中是隐含的，所以尾数部分从小数点后第一位开始填充。
	- 如果小数部分超过了 23 位，则舍入到第 23 位。
	- 如果小数部分不足 23 位，可以在尾数的末尾补零。
6. 拼接成最终的浮点数格式：最后将符号位、指数位和尾数位拼接起来，得到最终的 32 位 IEEE 754 单精度浮点数。

### 校验码

- 在实际应用中，奇偶校验多采用奇校验，这是因为奇校验中不存在全“0”代码，在某些场合下更便于判别。
- 例题：已知字符 "0" 的 7 位 ASCII 码是 30H，假设在 7 位 ASCII 的最高位前面添加一位偶校验位, 则字符 "1" 的偶校验 ASCII 码是 B1H。
	- 偶校验是指在被传送的 n 位代码上增加一位校验位，使得配置后的 n+1 位代码中 "1" 的个数是偶数个。接收端收到数据后，检验数据中 "1" 的个数，如果是偶数，则认为传输没有出错; 如果是奇数，则说明数据传输出错。
	- 由字符 "0" 的 ASCII 码推出字符 "1" 的 ASCII 码为 31H，转换为二进制为 0011 0001，1 的个数为 3，需要在最高位加一位偶校验位，得到的偶校验码为 1011 0001，即 B1H。

## CPU

### 基本概念

#### 机器字长

- CPU 一次能够处理的数据长度 (二进制位数) 称为机器字长，通常机器字长等于通用寄存器的长度。
- 机器字长通常与 CPU 的寄存器位数、加法器有关。所以机器字长一般等于内部寄存器的大小，字长越长，数的表示范围就越大，计算的精度就越高。
- 计算机字长通常都选定为字节的整数倍，不同的计算机字长可以不同。
- 指令字长一般都取存储字长的整数倍，如果指令字长等于存储字长的 2 倍，就需要两次访存，取指周期等于机器周期的 2 倍。
- 如果指令字长等于机器字长，则取指周期等于机器周期。指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数，与机器字长没有必然的联系。一般为了硬件设计方便，指令字长通常取字节或存储字长的整数倍。

#### 操作码

- 操作码是指令的一部分，用于指定处理器应该执行的基本操作。例如，指令可以包含加法、减法、存储、加载等操作。操作码通常是指令的前几位或最重要的位，它决定了计算机执行什么操作。操作码的大小通常取决于指令集架构（ISA）。比如，在某些体系结构中，操作码可能是 6 位、8 位或 16 位等。
	- 例子：加法操作（ADD）、减法操作（SUB）、乘法操作（MUL）、存储操作（STORE）、加载操作（LOAD）
- **扩展操作码**是一种指令优化技术，不同地址数指令可以具有不同的操作码长度。也就是让操作数地址多的指令的操作码字段短一些，操作数地址个数少的指令的操作码字段长一些，这样既能充分地利用指令的各个字段，又能在不增加指令长度的情况下扩展操作码的位数，使它能表示更多的指令。扩展操作码通常在复杂的指令集（如 RISC 或 CISC）中更常见，尤其是在支持多种操作模式或多种寻址模式的体系结构中。
	- 主要作用：扩展操作码通常用于处理复杂的操作指令，或者在指令中加入更多的控制信息，使得同一个操作码可以映射到多个不同的具体操作。例如，某些简单的指令可能会在基本操作码基础上，通过扩展操作码来指定不同的操作方式或不同的操作数。
	- 例子：假设某个指令系统的基本操作码是 6 位（有 64 个基本操作），但通过扩展操作码可以表示更多的指令类型或变种。例如，操作码 `000010` 可能表示”加法”操作，而扩展操作码 `00001001` 可能表示“带立即数的加法”。
- **隐指令**是指令系统中没有的指令，而不是指令系统中一条真正的指令，其没有操作码。例如，中断隐指令是一种不允许也不可能为用户使用的特殊指令。

### CPU 的组成

- CPU 主要包括控制器和运算器。
	- 程序计数器和指令寄存器属于控制器。计数器和移位器属于运算器。
	- 程序计数器 (PC) 用于指出下一条指令在主存中的存放地址，具有寄存信息和计数两种功能，位于控制器内。
	- 算数逻辑单元（ALU）的功能一般包括算术运算和逻辑运算。
	- 浮点运算可用两个松散连接的定点运算部件来实现：即阶码部件和尾数部件。浮点运算器的尾数部件实质上就是一个通用的定点运算器，要求该运算器能实现加、减、乘、除四种基本算术运算，阶码部件只进行阶码相加、相减和比较操作。
- Cache
	- Cache 存储器查找映射表和访问物理 Cache 期间可以流水，使速度与 CPU 匹配。
	- 采用指令 Cache 和数据 Cache 分离的主要目的是减少指令流水线资源冲突。
- I/O 接口
	- I/O 接口中 CPU 可访问的寄存器称为 I/O 端口。
	- 状态端口和控制端口可以合用同一个寄存器。
	- 采用统一编址方式时，CPU 能用访存指令访问 I/O 端口。统一编址是指把 I/O 端口当作存储器的单元进行地址分配，使用这种方式 CPU 不用设置专门的 I/O 指令，用统一的访存指令就可以访问 I/O 端口。
	- 采用独立编址方式时，I/O 端口地址和主存地址可能相同。
- 地址译码器位于主存中，不位于 CPU 中。
- 硬连线控制器中，使用节拍发生器来区别指令不同的执行步骤。
- 例题：74181 芯片是 4 位 ALU（算术逻辑单元）电路，可以完成 16 种算术运算和 16 种逻辑运算。
- 例题：能缩短程序执行时间的措施包括了：
	1. 提高 CPU 时钟频率
	2. 优化数据通路结构
	3. 对程序进行编译优化
	- 解析如下：
		1. CPU 的时钟频率也就是 CPU 主频。一般说来，一个时钟周期内完成的指令数是固定的，所以主频越高，CPU 的速度就越快，程序的执行时间就越短。
		2. 数据在功能部件之间传送的路径称为数据通路，数据通路的功能是实现 CPU 内部的运算器和寄存器以及寄存器之间的数据交换。优化数据通路结构，可以有效提高计算机系统的吞吐量，从而加快程序的执行。
		3. 计算机程序需先转化为机器指令序列才能最终得到执行，通过对程序进行编译优化可以得到更优的指令序列，从而使程序的执行时间缩短。

### CPU 周期

- 计算机主频的周期是指时钟周期。
- 机器周期又称 CPU 周期，一个指令周期常由若干 CPU 周期构成。
- 指令周期是指 CPU 从主存中取出一条指令加上执行这条指令的时间。
- CPI 是指执行一条指令所需要的时钟周期数。
- 流水线的操作周期应以最长的指令执行时间为准。组成指令流水线的各功能段的执行时间最好尽量相等。为了充分发挥流水线的作用，CPU 时钟周期应取各功能段时间的最大值，使得各功能段能在 CPU 的统一时钟控制下执行。因此，组成指令流水线的各功能段的执行时间最好相等，否则会引起“堵塞”或“断流”现象，使得时间长的功能段成为整个流水线的“瓶颈”。
- 例题：流水线中的相关问题是指在一段程序的相邻指令之间存在某种信赖关系，这种关系影响指令的执行。

### 寻址

寻址方式（Addressing Mode）是指计算机系统中如何确定操作数（如数据、变量、常量等）所在位置的一种机制。不同的寻址方式决定了如何从内存或寄存器中提取操作数。
- 例题：为了缩短指令中某个地址段的位数，比较有效的方法是采用寄存器寻址方式。
	- 由于寄存器寻址中，只需指定寄存器的编号，因此能有效地缩减地址码的位数。
- 例题：支持动态地址再定位的寻址方式是基址寻址。
	- 在基址寻址方式中，操作数的有效地址等于基址寄存器的内容加上形式地址。基址寻址的优点是可扩大操作数的寻址范围和解决程序在主存中的再定位等问题。
- 例题：变址寻址便于处理数组问题。

#### 立即寻址（Immediate Addressing）

在立即寻址模式下，操作数直接作为指令的一部分给出，而不是通过地址来访问内存中的数据。即操作数值直接嵌入在指令中。
- 优点：操作数是固定的，执行效率高。
- 缺点：无法改变操作数，只能使用固定的值。
- 示例：

```assembly
MOV R0, #10  ; 将立即数 10 存入寄存器 R0
```

#### 寄存器寻址（Register Addressing）

在寄存器寻址模式下，操作数存储在寄存器中，指令直接给出寄存器的编号。操作数的存储位置是寄存器，而不是内存。
- 优点：访问速度快，直接使用寄存器操作。
- 缺点：寄存器数量有限，操作数的存储空间较小。
- 示例：

```assembly
MOV R0, R1  ; 将寄存器 R1 的内容复制到寄存器 R0
```

#### 直接寻址（Direct Addressing）

在直接寻址模式下，指令包含的是内存地址。操作数位于该地址中，处理器通过该地址直接访问内存。
- 优点：访问内存中的特定位置。
- 缺点：每条指令必须包含一个内存地址，导致指令长度较长。
- 示例：

```assembly
MOV R0, [1000]  ; 从内存地址 1000 读取数据并存入寄存器 R0
```

#### 间接寻址（Indirect Addressing）

在间接寻址模式下，指令指定的是一个内存地址，而该地址存储的是操作数的实际地址。通过该地址间接访问操作数。
- 优点：支持动态寻址，可以使用指针访问数据。
- 缺点：比直接寻址慢，因为需要先读取一个地址。
- 示例：

```assembly
MOV R0, [R1]  ; 从寄存器 R1 中存储的内存地址读取数据并存入寄存器 R0
```

#### 寄存器间接寻址（Register Indirect Addressing）

寄存器间接寻址是一种特殊形式的间接寻址，其中操作数的地址存储在一个寄存器中。通过该寄存器中的值间接访问内存。
- 优点：避免了在指令中使用固定的内存地址，可以通过修改寄存器来动态更改操作数。
- 缺点：依赖于寄存器中的值，访问时需要额外的一步读取寄存器。
- 示例：

```assembly
MOV R0, (R1)  ; 从寄存器 R1 中存储的地址加载数据到寄存器 R0
```

#### 基址寻址（Base Addressing）

基址寻址是将一个基址寄存器与一个偏移量（通常是指令的一部分）结合来计算实际的内存地址。常用于访问结构体、数组等数据结构。
- 优点：方便访问数据结构中的元素，尤其在数据结构的基础地址已知的情况下。
- 缺点：需要基址寄存器和偏移量，可能需要多次计算。
- 示例：

```assembly
MOV R0, [R1 + 4]  ; 将基址寄存器 R1 加上偏移量 4 的地址的内容读取到寄存器 R0
```

#### 变址寻址（Indexed Addressing）

变址寻址模式类似于基址寻址，但这里使用的是索引寄存器和一个常量偏移量的和来计算内存地址。常用于数组元素的访问。
- 优点：非常适合处理数组和表格数据。
- 缺点：需要两个寄存器和偏移量的计算。
- 示例：

```assembly
MOV R0, [R1 + R2]  ; 将寄存器 R1 和 R2 中的值相加，作为内存地址来读取数据
```

#### 相对寻址（Relative Addressing）

相对寻址模式下，指令给出的地址是相对于程序计数器（PC）的偏移量。该模式通常用于实现跳转（如条件跳转、循环等）。
- 优点：非常适合分支跳转，尤其是在编写操作系统或控制流语句时。
- 缺点：无法直接访问任意内存地址，只能访问相对位置。
- 示例：

```assembly
JMP label  ; 跳转到程序中相对于当前指令的某个标签位置
```

#### 堆栈寻址（Stack Addressing）

堆栈寻址模式下，操作数通过堆栈进行访问，指令通过栈顶地址来访问操作数。常见于函数调用和返回。
- 优点：支持递归调用和局部变量的管理。
- 缺点：堆栈操作可能会增加程序的复杂性。
- 示例：

```assembly
PUSH R0  ; 将寄存器 R0 的值压入堆栈
POP R0   ; 从堆栈弹出数据并存入寄存器 R0
```

#### 抽象寻址（Complex Addressing）

抽象寻址模式是一种复合型的寻址模式，可以结合多种寻址方式，例如基址加偏移量加变址等，进行多步计算。这通常出现在复杂的系统中。

### RISC 和 CISC

| 特点           | RISC (精简指令集计算机)     | CISC (复杂指令集计算机)     |
| ------------ | ------------------- | ------------------- |
| **指令集**      | 简单，少量指令             | 复杂，指令多且功能强大         |
| **指令长度**     | 固定长度                | 不固定长度               |
| **每条指令执行时间** | 通常相同                | 不同，取决于指令的复杂度        |
| **寄存器使用**    | 依赖大量寄存器             | 可以直接访问内存            |
| **内存访问**     | 通过寄存器，减少内存访问        | 支持直接内存操作            |
| **代码效率**     | 代码量较大，需要更多指令来实现复杂操作 | 代码量较小，能用较少的指令完成更多操作 |
| **硬件复杂性**    | 较简单，硬件实现易于优化        | 硬件实现复杂，指令解码较为复杂     |
| **性能优化**     | 高效的指令流水线和编译器优化      | 依赖硬件执行复杂指令，流水线效率较低  |
| **典型代表**     | ARM, MIPS, SPARC    | x86, VAX            |

### 零地址指令

零地址指令是一种用于计算机系统的指令类型，它的特点是指令中不显式包含操作数地址。零地址指令的操作数和结果通常存放在栈（stack）中，依赖栈的后进先出（LIFO）特点来完成操作。

#### 工作原理

- 栈操作：零地址指令的计算基于栈结构，栈是一种特殊的数据存储方式，具有后进先出的特性。
    - 操作数通过 PUSH 指令压入栈中。
    - 指令在执行操作时，直接从栈顶弹出操作数，计算后将结果压入栈中。
- 隐式操作：零地址指令没有明确的操作数地址，而是隐式地依赖栈进行操作。所有的运算都只对栈顶的数据进行。

#### 零地址指令的特点

- 无操作数地址：指令中不需要指明操作数地址，操作数默认从栈顶弹出。
- 栈操作为基础：依赖栈的后进先出特性，操作数通过栈操作实现。
- 适合后缀表达式（逆波兰表达式）：由于栈的特点，零地址指令特别适合计算后缀表达式。

#### 示例

计算表达式 $A + B \times C$：

1. 表达式的后缀形式为：$A \, B \, C \, \times \, +$。
2. 使用零地址指令进行计算的过程如下：
	- 假设：
		- 操作数 $A = 2，B = 3，C = 4$。
		- 栈操作：`PUSH`（压栈）、`POP`（弹栈）。
	- 操作步骤：
		1. PUSH A：将 A（值为 2）压入栈。
		    - 栈状态：`[2]`
		2. PUSH B：将 B（值为 3）压入栈。
		    - 栈状态：`[2, 3]`
		3. PUSH C：将 C（值为 4）压入栈。
		    - 栈状态：`[2, 3, 4]`
		4. MUL：弹出栈顶的两个元素（3 和 4），计算乘积 $3 \times 4 = 12$，将结果压入栈。
		    - 栈状态：`[2, 12]`
		5. ADD：弹出栈顶的两个元素（2 和 12），计算和 $2 + 12 = 14$，将结果压入栈。
		    - 栈状态：`[14]`

	- 最终结果：栈顶的值 14 即为计算结果。

#### 优缺点

- 优点：
	1. 指令简单：零地址指令无需指定操作数地址，指令格式简单。
	2. 栈操作高效：直接利用栈结构处理操作数，适合嵌套和递归运算。
	3. 表达式计算方便：特别适合后缀表达式（逆波兰表达式）的计算。
- 缺点：
	1. 对栈依赖强：所有运算都必须依赖栈完成，栈操作频繁可能降低效率。
	2. 难以随机访问：由于栈是后进先出的结构，不支持随机访问，可能限制某些复杂场景的实现。
	3. 硬件实现复杂：需要专门的栈指针和相关硬件支持。

#### 与其他地址指令的比较

| 特性        | 零地址指令       | 单地址指令     | 双地址指令     |
| --------- | ----------- | --------- | --------- |
| **操作数地址** | 无显式地址，隐式使用栈 | 一个显式操作数地址 | 两个显式操作数地址 |
| **适合场景**  | 后缀表达式计算     | 简单运算      | 更复杂的运算    |
| **指令长度**  | 最短          | 中等        | 较长        |

#### 典型应用

- 零地址指令广泛用于栈式计算机（Stack Machine），如早期的 Java 虚拟机（JVM）字节码指令集。
- 适合基于栈的表达式求值、递归算法实现等。

### 微指令

#### 微程序

- 微程序设计的概念是，将一条机器指令编写成一个微程序，每一个微程序包含若干条微指令，每一条微指令对应一个或几个微操作命令。然后把这些微程序存放到一个控制存储器中，用寻找用户程序机器指令的方法来寻找每个微程序中的微命令。
	- 例题：微程序存放在只读存储器中。
	- 例题：在微程序控制中，操作控制信号将编成微指令形式。
	- 例题：直接执行微指令的是硬件。

#### 微指令编码方式

微指令字段编码法和直接编码法是两种实现微指令控制的方式，它们在计算机架构中用于实现控制单元的功能，特别是在微程序控制中。

##### 微指令字段编码法（Field Encoding Method）

微指令字段编码法是一种将微指令的各个控制字段分别编码，并通过这些编码来控制不同功能的实现。每一位或每一段字段对应一个控制信号。通过这种方式，可以将一条微指令拆解为多个不同的字段，每个字段控制不同的硬件功能。
- 结构：微指令一般包含多个字段，每个字段控制一个特定的操作或状态。
	- 举例：
		- 操作码字段：指定要执行的操作（如加法、减法、存储等）。
		- 地址字段：指定操作数的位置或寄存器地址。
		- 状态字段：用于设置标志位或其他硬件状态。
	通过字段编码法，每个字段在指令中的位置是预定义的，因此控制信号的组合可以在指令中通过设置不同的字段来完成。
- 优点：
	- 灵活性高：每个字段可以控制不同的硬件组件，能够组合出复杂的控制逻辑。
	- 扩展性强：可以根据需要添加新的字段或修改现有字段的大小。
- 缺点：
	- 复杂性高：需要设计多个字段并编码，需要多级的控制逻辑。
	- 指令长度较长：由于每个字段都占用一定的位数，微指令的长度可能会增加。
- 示例：假设我们有一条微指令，它可能包含以下几个字段：
	- 操作码字段（例如 6 位）：用来指定运算操作类型（如加法、减法）。
	- 寄存器字段（例如 4 位）：用来指定操作数所在的寄存器。
	- 内存地址字段（例如 8 位）：用来指定内存地址。
	- 控制信号字段（例如 2 位）：用来控制外部硬件组件的启用。

##### 直接编码法（Direct Encoding Method）

直接编码法是指微指令直接通过一个简单的二进制编码来指定控制信号，每一条微指令的每一位都代表一个特定的控制信号。这种方法常用于微程序控制中，通过直接设置控制信号来控制硬件组件。
- 结构：在直接编码法中，每一条微指令的每一位或每一组位都直接对应一个特定的硬件操作或控制信号。即：
	- 每个控制信号的状态由微指令的对应位直接控制。
	- 不需要复杂的字段划分，控制信号是“直接”的。
- 优点：
	- 简单易理解：每个控制信号直接对应一个二进制位，逻辑清晰，容易实现。
	- 速度快：由于没有复杂的字段划分，控制信号的获取和解析速度较快。
- 缺点：
	- 灵活性差：每个控制信号固定对应一位，无法灵活组合控制多个信号。
	- 扩展性差：如果需要增加新的控制信号，必须修改微指令的编码，可能导致指令长度增加。
- 示例：假设我们有一条微指令，微指令中的每一位可以直接代表一个控制信号，例如：
	- 第 1 位控制加法操作。
	- 第 2 位控制减法操作。
	- 第 3 位控制寄存器 A。
	- 第 4 位控制寄存器 B。
	如果要执行加法操作，可以设置第 1 位为 1，而其他位为 0，指令可能是 `1000`。

##### 微指令表示格式总结

- 直接表示法：特点是操作控制字段中的每一位代表一个微命令。这种方法的优点是简单直观，其输出直接用于控制；缺点是微指令字较长，因而使控制存储器容量较大。
- 字段编码法：把一组互斥性的微命令信号组成一个小组（即一个字段），然后通过小组（字段）译码器对每一个微命令信号进行译码，译码输出作为操作控制信号。
- 混合表示法：是把直接表示法与字段编码法混合使用，以便能综合考虑指令字长、灵活性、执行微程序速度等方面的要求。

## 存储设备与外设

### 存储层次

- 计算机存储系统的层次结构主要体现在”缓存 - 主存“和”主存 - 辅存“这两个存储层次上，构成了缓存、主存、辅存三级存储系统。
- ”缓存 - 主存“层次主要解决了 CPU 和主存速度不匹配的问题。
- ”主存 - 辅存“层次主要解决了存储系统容量的问题。

### 寄存器

- 汇编语言程序员可见的是程序计数器 (PC)，程序计数器中存放的是下一条需要执行的指令，因而程序员可以通过转移指令、调动子程序等指令来改变其内容。用户可以通过程序去访问的寄存器，如通用寄存器组、程序计数器等，称为用户可见寄存器。
- MAR（存储器地址寄存器）、MDR（存储器数据寄存器）和 IR（指令寄存器）是 CPU 内部工作寄存器，在程序执行过程中是自动赋值的, 程序员无法对其操作，称为用户不可见寄存器。
	- 用于存放当前 CPU 所访问的主存单元地址的寄存器是存储器地址寄存器，存放由主存读出的数据或指令的寄存器是存储器数据寄存器。
	- 例题：某机字长 32 位，存储容量为 64 MB，若按字编址，则存储器地址寄存器 MAR 和存储器数据寄存器 MDR 的位数分别为 24、32。
		- 根据题意得 $64 \text{ MB} = 2^{26} \times 8 \text{ bit} = 2^{24} \times 32 \text{ bit}$。
- 指令寄存器 (IR) 用来保存当前正在执行的一条指令。
	- 例题：计算机指令一般包括操作码和地址码两部分，为分析执行一条命令，其操作码和地址码都应存入指令寄存器（IR）。
	- 例题：CPU 中用来保存当前正在执行指令的寄存器是指令寄存器。
- 程序状态字寄存器中的各个状态标志位是依据算术逻辑部件上次的运算结果来置位的。
- 通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长。
- 例题：某寄存器中的值有时是地址，这只有计算机的指令才能识别它。
	- 严格来说，读进来的都是指令，每一条指令里面又分为操作码和地址码两部分，其中地址码部分有可能没有。操作码用来指明该指令所要完成的操作；地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。
- 例题：在 CPU 中，累加寄存器可用于传送和暂存用户数据，为 ALU 执行算术逻辑运算提供工作区。
	- 累加寄存器是一个通用寄存器，功能是当运算器的算术逻辑运算单元 ALU 执行算术运算或逻辑运算时，为 ALU 提供一个工作区。累加寄存器暂时存放 ALU 运算的结果信息。

### DMA

全称 Direct Memory Access，即直接存储器访问。DMA 用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须 CPU 的干预，通过 DMA 数据可以快速地移动。这就节省了 CPU 的资源来做其他操作。
- 详细解释：DMA 方式是一种完全由硬件进行成组信息传送的控制方式，具有程序中断方式的有优点，即在数据准备阶段，CPU 与外设并行。它还降低了 CPU 在传送数据时的开销，因为信息传送不再经过 CPU，而在外设与内存之间直接进行，因此也称为直接存储器存取方式。由于数据不经过 CPU，也就不需要保护、恢复 CPU 现场等烦琐操作，所以这种方式很适用于磁盘、磁带、硬盘等高速设备大批量数据的传送。
	- 例题：在微机系统中，主机与高速硬盘进行数据交换一般用 DMA 方式。
	- 例题：DMA 数据的传送是以数据块为单位进行的。
- 在 DMA 方式下，数据从主存传送到外设经过的路径是主存 $\rightarrow$ 数据总线 $\rightarrow$ DMAC $\rightarrow$ 外设。

### 主存

- 主存（Main Memory），又称为内存，是计算机系统中用于存储程序和数据的核心部分。它是处理器和其他硬件组件直接访问和操作的存储空间。主存的速度较快，并且提供了在程序执行时对数据和指令的高速访问。
	- 例题：微型计算机的内存编址方式是按字节编址。
- 主存的两大基本类型是随机存取存储器（RAM）和只读存储器（ROM）。这两者在功能、用途和性能上各有不同。
- 例题：DRAM、SRAM、EPROM 采用随机存取方式，CD-ROM 是只读型光盘存储器，采用串行存取方式。

#### 随机存取存储器（RAM）

RAM（Random Access Memory）是计算机中一种主要的**读写**存储器，允许数据在任何时刻被读取或写入。RAM 通过地址和数据总线与处理器进行交互，使得程序可以快速读取和写入数据。RAM 是计算机中主要的工作存储器，通常用于存储正在运行的程序和数据。
- 特点：
	- 读写存储器：RAM 的内容可以被随时修改和读取，因此它是易失性的内存。
	- 速度快：相比于硬盘或其他外部存储设备，RAM 的访问速度非常快。
	- 易失性：当计算机断电时，RAM 中的数据会丢失，这就是为什么 RAM 用来存储程序的临时数据，而非长期数据。
	- 容量较大：RAM 的容量通常比 ROM 大，通常范围从几 GB 到几十 GB 不等。
- 类型：
	1. 动态随机存取存储器（DRAM）：
	    - 特点：需要周期性地刷新其内容，以保持数据。相对成本较低，但访问速度相对较慢。
	    - 应用：广泛应用于计算机的主内存中，容量大且价格相对较便宜。
	2. 静态随机存取存储器（SRAM）：
	    - 特点：无需刷新，其内容保持不变，速度更快，但单位存储成本较高。
	    - 应用：常用于高速缓存（Cache）和嵌入式系统中。
- 作用：
	- 程序执行：RAM 存储着操作系统、应用程序以及正在执行的进程所需的代码和数据。
	- 数据存储：临时存储用户输入、缓存数据等。
	- 内存缓存：提高数据访问速度，减少 CPU 和存储设备之间的数据传输延迟。
- 优缺点：
	- 优点：读写速度快，支持随机访问，方便高效地处理数据。
	- 缺点：容量有限，且由于其易失性，一旦电源关闭，数据会丢失。

##### DRAM 芯片

- 动态随机存储器，又称动态 RAM（dynamic random-access memory, DRAM，台湾作动态随机存取记忆体），是一种半导体存储器，通常被用作主存储器，用于存储运行中的程序和数据。在 DRAM 中，每个记忆单元由一个电容和一个晶体管组成，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特（bit）是 1 还是 0。与大部分的随机存储器（RAM）一样，存在 DRAM 中的资料会在电力切断以后很快消失，因此它属于一种易失性存储器（volatile memory）设备。
- 例题：某 DRAM 芯片，其存储容量为 512K $\times$ 8 位, 该芯片的地址线和数据线数目分别为 19、8。
	- 存储容量：$512K = 2^{19}$ 个存储单元，对应 19 根地址线。
	- 数据传输：8 位表示一次可以读/写 8 位（1 字节）数据，因此需要 8 根数据线。

#### 只读存储器（ROM）

ROM（Read-Only Memory）是计算机中一种**只读**存储器，用于长期存储数据，通常存储着计算机系统的固件、启动程序以及一些不经常更改的数据。ROM 中的数据在制造时就被写入，通常无法或难以修改。
- 特点：
	- 只读：ROM 是不可直接修改的数据存储设备，通常只能读取数据，不能进行随意的写入操作。
	- 非易失性：当电源关闭时，ROM 中的数据不会丢失，这使得它适合用于存储固化的系统程序或启动代码。
	- 较慢的访问速度：与 RAM 相比，ROM 的访问速度较慢。
- 类型：
	1. 掩模 ROM（Mask ROM）：
	    - 特点：数据在生产时就已经被写入，无法修改。通常用于一些固定的、长期不变的程序。
	    - 应用：用于存储计算机的启动程序、嵌入式系统中的固件等。
	2. 可编程只读存储器（PROM）：
	    - 特点：用户可以一次性编程，但之后无法修改。
	    - 应用：用于需要用户写入一次数据的场景，如计算机 BIOS。
	3. 可擦写可编程只读存储器（EPROM）：
	    - 特点：可以通过紫外线擦除数据并重新编程。EPROM 存储的内容可以通过紫外线暴露清除，之后重新写入。
	    - 应用：曾用于一些需要频繁修改的固件或小规模生产的设备。
	4. 电可擦写只读存储器（EEPROM）：
	    - 特点：可以通过电流擦除和重写，且可以逐字节地擦除和写入数据。相比 EPROM，EEPROM 可以在更便捷的情况下进行修改。
	    - 应用：广泛用于存储计算机硬件设置、嵌入式系统、微控制器等。
- 作用：
	- 固件存储：存储计算机的基本输入输出系统（BIOS）、启动加载程序（Bootloader）、嵌入式系统的固件等。
	- 系统配置：存储系统的配置信息或固定数据，确保系统在每次启动时都能加载正确的配置。
- 优缺点：
	- 优点：非易失性，不会因为断电丢失数据；数据可靠性高，适合存储系统的重要数据和程序。
	- 缺点：写入速度慢，且某些类型的 ROM 不支持后期修改。

### 相联存储器

相联存储器（Associative Memory），也称为内容可寻址存储器（Content Addressable Memory，简称 CAM），是一种特殊类型的计算机存储器，它的存储方式与常规存储器（如 RAM）不同。相联存储器允许通过数据内容而不是地址来检索存储的数据。也就是说，用户输入的是数据项，而不是存储地址，存储器根据数据内容返回存储项的位置或相应的结果。

### 交叉存储器

交叉存储器中有多个容量相同的存储模块（存储体），各存储模块有各自独立的地址寄存器、读写电路和数据寄存器，这就是多体系统。各个存储体能并行工作，又能交叉工作。

### 磁盘

- 硬盘接口是硬盘与主机系统间的连接部件。从整体的角度上，硬盘接口可分为 SATA、IDE 和 SCSI 等。
- 硬盘的主要性能指标包括磁盘容量、磁盘转速、道密度、平均存取时间、缓存和数据传输率。
- RAID 是无冗余和无校验的磁盘阵列，而 RAID1 - RAID5 均是加入了冗余（镜像）或校验的磁盘阵列，因此能够提高 RAID 可靠性的措施主要是对磁盘进行镜像处理和奇偶校验。
- 硬盘驱动器向盘片磁道记录数据时采用串行方式写入。

### 记录方式

常见的记录方式包括调频制、归零制、不归零制和调相制。这些方式主要涉及如何表示二进制数据（如 0 和 1）并控制信号的变化方式，以便有效地存储和读取数据。

#### 调频制 (FM, Frequency Modulation)

调频制（FM）是一种常用于磁盘存储器的数据编码方式，属于一种 二进制数据的编码方式，其主要特点是通过信号频率的变化来表示数据。
- 工作原理：
	- 在调频制中，每个 1 被表示为一个高频信号（或某一固定频率），而每个 0 则通过低频信号（或更低的频率）来表示。
	- 一般来说，为了保证数据的同步性，FM 编码会采用一个固定的频率基准（例如，每个 0 至少有一个短的“空白”），从而保证信号能够被正确地解码。
- 特点：
	- 同步性好：由于每个 0 和 1 都有明显的频率变化，FM 能够提供良好的同步性，适合长时间的数据存储。
	- 高频信号易于检测：在磁盘存储中，FM 通过高频信号来表示“1”使得数据在读取时容易被检测到。
	- 存储效率较低：由于频率编码方式增加了额外的信号，它的存储密度和带宽利用率较低。
- 应用：早期的磁盘存储和某些带磁存储设备中使用过调频制。

#### 归零制 (NRZ, Non-Return to Zero)

归零制（NRZ）是一种非常简单的编码方式，它是最基本的二进制编码方法之一。
- 工作原理：
	- 在归零制中，1 通常表示为高电平（例如 +V），0 表示为低电平（例如 0V）。这种表示方式没有中间状态，信号只在高电平和低电平之间转换。
	- 例如，数据 `1010` 会依次在电压上表示为高电平、低电平、高电平、低电平。
- 特点：
	- 简单、快速：由于没有中间状态或复杂的编码，归零制的实现较为简单且传输效率高。
	- 同步问题：由于没有任何频率变化，数据传输过程中容易出现同步问题，尤其在长时间的零信号（例如一段连续的零）时会丧失同步。
	- 存储效率高：在某些情况下，归零制编码具有较高的存储密度。
- 应用：广泛用于早期的存储设备，但由于同步问题，现代系统不常用这种编码方式。

#### 不归零制 (NRZI, Non-Return to Zero Inverted)

不归零制（NRZI）是一种对归零制的扩展方式，主要是通过反转信号来表示数据。
- 工作原理：在不归零制中，0 保持电平不变（不改变电平），而 1 则通过反转电平来表示。例如，在“1”时，电压从高到低或从低到高发生变化，而“0”保持不变。即连续的 0 不会影响信号的状态，而 1 会引起信号电平的变化。
- 特点：
	- 避免长时间的 0：通过在“1”处引入电平反转，不归零制避免了长时间连续的 0 信号，可以提高同步性。
	- 易于实现：NRZI 的实现比归零制稍微复杂，但仍然相对简单。
	- 较高的存储效率：相比调频制和归零制，NRZI 可以提供较高的数据传输率和存储密度。
- 应用：常用于数据存储和传输中，例如某些类型的磁盘存储和光盘存储中。

#### 调相制 (Manchester Encoding)

调相制（Manchester 编码）是一种通过信号的相位变化来表示数据的编码方式。
- 工作原理：在调相制中，每个比特值都通过信号的相位变化来表示：
	- 1 被表示为一个高电平到低电平的过渡（即正边沿）；
	- 0 被表示为一个低电平到高电平的过渡（即负边沿）。
	- 每个比特都需要两个时钟周期，因此每个比特的传输时间较长，但它确保了信号有明确的过渡，保证了高精度的同步。
- 特点：
	- 自同步性强：由于每个比特都有一个相位变化，调相制非常适合长距离或高噪声环境中的数据传输，能保证很好的时序同步。
	- 较低的存储效率：由于每个比特需要两个时钟周期，调相制的存储效率较低，数据传输速度相对较慢。
	- 容错性好：调相制具有较强的抗噪声能力和信号传输稳定性。
- 应用：常见于网络协议（如 Ethernet）、硬盘存储（如一些磁带驱动器）和其他数据传输系统。

### CRT

- CRT（阴极射线管）是一种传统的显示技术，广泛用于电视机、计算机显示器等设备中，尤其在 20 世纪末期以前。它通过电子枪发射电子束，通过磁场或电场控制电子束的方向，将电子束打在荧光屏上产生图像。
- 刷新存储器是指一种存储器，通常用于保存图像信息的显示内容，它的作用是在显示设备中不断刷新（更新）屏幕上的图像。刷新存储器中存储的是图像的像素数据，显示器通过不断地读取这些数据并在屏幕上重新绘制来保持图像的显示。
- 例题：CRT 的分辨率为 1024 $\times$ 1024 像素，像素的颜色数为 256, 则刷新存储器的容量是 1MB。
	- 每个像素的存储位数：256 色意味着每个像素可以表示 256 种颜色。为了表示 256 种不同的颜色，需要使用 8 位（因为 $2^8 = 256$）。因此，每个像素需要 8 位存储空间。
	- 总像素数：分辨率为 1024 $\times$ 1024，所以总像素数为： $1024 \times 1024 = 1,048,576$ 像素。
	- 存储器容量：
	    - 每个像素需要 8 位（即 1 字节），所以总存储容量为：$1,048,576 \text{ 像素} \times 1 \text{ 字节} = 1,048,576 \text{ 字节}$
	    - 由于 1 KB = 1024 字节，所以换算成 KB：$1,048,576 \text{ 字节} \div 1024 = 1024 \text{ KB}$
    - 换算成 MB（1 MB = 1024 KB）：$1024 \text{ KB} \div 1024 = 1 \text{ MB}$
- 例题：假定一台计算机的显示存储器用 DRAM 芯片实现，若要求显示分辨率为 1600 $\times$ 1200，颜色深度为 24 位，帧频为 85Hz，显示总带宽的 50% 用来刷新屏幕，则需要的显存总带宽至少约为 7834 Mbps。
	- 计算刷新带宽：刷新屏幕时每秒需要的数据量为 $\text{刷新带宽} = \text{分辨率} \times \text{颜色深度} \times \text{帧频}$。代入数据：$\text{刷新带宽} = 1600 \times 1200 \times 24 \, \text{bit} \times 85 \, \text{Hz}$。将位数转换为字节（1 字节 = 8 位）：$\text{刷新带宽} = 1600 \times 1200 \times 3 \, \text{byte} \times 85 = 489,600,000 \, \text{byte/s}$。即：$\text{刷新带宽} = 489.6 \, \text{MB/s}$。
	- 计算显存总带宽：由于刷新屏幕占用了 50% 的显存总带宽，因此 $\text{显存总带宽} = \frac{\text{刷新带宽}}{50\%} = 2 \times \text{刷新带宽}$。代入数据：$\text{显存总带宽} = 2 \times 489.6 \, \text{MB/s} = 979.2 \, \text{MB/s}$。也就是 7834 Mbps。

## 数据传输与控制

### 总线系统

- 在单机系统中，多总线结构的计算机的总线系统一般由系统总线、内存总线和 I/O 总线组成。
	- 系统总线用于 CPU 和内存之间传送地址、数据和控制信息。
	- 内存总线使内存和高速外设之间能够直接传送数据。
	- I/O 总线提供 CPU 和各类外设之间的通信。
- 片内总线是指芯片内部的总线。例如，在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算数逻辑单元之间都是由片内总线连接的。
	- 例题：CPU 芯片中的总线属于片内总线。
- 系统总线是计算机系统内部各功能部件（CPU、主存、I/O 接口）之间相互连接的总线。系统总线按传送信息的不同可分为数据总线、地址总线和控制总线。
	- 例题：系统级的总线是用来连接系统中的各个功能模块或设备。
	- 地址总线用来指出数据总线上的源数据或者目的数据所在的主存单元或 I/O 端口的地址。
	- 在微机系统中，外设通过设备控制器与主板的系统总线相连接。
	- 主存通过总线的类型来识别信息属于地址还是数据。通常，地址和数据在不同的总线上传输，地址在地址总线上传输，数据在数据总线上传输。
	- 例题：在计算机总线中，地址信息、数据信息和控制信息不能同时出现。
- 不同信号在同一条信号线上分时传输的方式称为总线复用方式。串行传输是指数据的传输在一条线路上按位进行。并行传输是每个数据位都需要单独一条传输线，所有的数据位同时进行传输。
- 在单总线、双总线、三总线的计算机系统中，外设可以和主存储器单元统一编址。
	- 计算机的各个部件均由系统总线相连。在单总线结构中，CPU 与主存之间、CPU 与 I/O 设备之间、I/O 设备与主存之间、各种设备之间都通过系统总线交换信息。单总线结构的优点是控制简单，扩充方便。但由于所有设备部件均挂在单一总线上，使这种结构只能分时工作，即同一时刻只能在两个设备之间传送数据。
- 通信方式
	- 异步总线即采用异步方式通信的总线。在异步方式下，是没有统一的时钟的，完全依靠传送双方相互制约的“握手”信号来实现定时控制。传送操作是由双方按需求分配时间的。
		- 例题：在异步总线中，传送操作按需分配时间。
	- 同步通信方式中，系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系，而不是由各设备提供时钟信号。
	- 半同步通信方式中，握手信号的采样由同步时钟控制。
- USB 总线
	- 可实现外设的即插即用和热插拔。
	- 可通过级联方式连接多台外设。
	- 属于通信总线的一种，用于连接不同的外设。
- USB 是串行总线，PCI、ISA 和 EISA 均是并行总线。
- 计算机局部总线包括：PCI、AGP、VESA。
	- ISA 是系统总线。

### 中断

- 中断允许触发器用来开放或关闭可屏蔽硬中断。
- 中断装置和中断处理程序统称为中断系统。中断系统是计算机的重要组成部分，是由硬件与软件结合实现的。
- CPU 响应中断必须满足 3 个条件：
	1. 中断源有中断请求。
	2. CPU 允许中断及开中断。
	3. 一条指令执行完毕，且没有更紧迫的任务。

### 中断向量

中断向量（Interrupt Vector） 是中断处理机制中的关键概念，用于管理和定位不同中断服务程序（Interrupt Service Routine, ISR）的入口地址。通过中断向量，系统能够快速响应不同的中断请求。

#### 基本概念

- 定义：中断向量是一个存储中断服务程序入口地址的表，称为中断向量表（Interrupt Vector Table, IVT）。
- 作用：当某个中断发生时，系统会根据中断号或中断请求源，从中断向量表中找到对应中断服务程序的入口地址，跳转到该地址执行中断处理。

#### 工作流程

1. 中断发生：外部设备或内部事件通过中断控制器向 CPU 发出中断请求。
2. 中断号确定：中断控制器将中断号（Interrupt Number）传递给 CPU。
3. 访问中断向量表：
    - 中断号作为索引，用于查找中断向量表中对应的服务程序地址。
4. 跳转执行：
    - CPU 跳转到中断向量表中指定的地址，开始执行中断服务程序。
5. 中断处理完成：
    - 中断服务程序执行结束后，CPU 恢复到中断发生前的状态，继续执行主程序。

#### 中断向量表组织方式

中断向量表通常是一个数组或表格，存储在系统内存的固定位置。具体组织方式与硬件架构有关。
1. 表项内容
	- 每个中断向量表项包含一个中断服务程序的入口地址。
	- 表项大小通常为 2 字节（16 位）或 4 字节（32 位），具体取决于系统的地址宽度。
2. 地址计算：中断服务程序的入口地址计算公式为 $\text{服务程序入口地址} = \text{基地址} + (\text{中断号} \times \text{表项大小})$。
3. 存储位置
	- x86 架构：中断向量表通常存储在内存的低地址区域（如 0x0000 - 0x03FF）。
	- ARM 架构：中断向量表的位置通常由硬件决定，可能位于地址 0x0000 或 0xFFFF0000。

#### 实现方式

根据硬件和系统设计的不同，中断向量有以下实现方式：
1. 静态中断向量
	- 中断服务程序地址是固定的，直接存储在中断向量表中。
	- 优点：实现简单。
	- 缺点：灵活性差，无法动态更改服务程序。
2. 动态中断向量
	- 中断服务程序地址可以动态修改，通过软件配置中断向量表。
	- 优点：灵活性高，适合多任务系统。
	- 缺点：实现复杂。

#### 优缺点

- 优点：
	1. 快速查找：通过中断号直接定位服务程序地址，响应速度快。
	2. 结构清晰：中断向量表的组织方式明确，便于管理。
	3. 支持多中断源：通过中断号区分不同中断源，支持复杂的中断系统。
- 缺点：
	1. 依赖存储空间：中断向量表需要占用内存空间。
	2. 可能存在冲突：如果多个中断共享同一中断号，可能导致冲突。

#### 示例：x86 架构的中断向量表

- x86 处理器的中断向量表（IVT）通常存储在内存的 0x0000 至 0x03FF 区域。
- 每个中断向量占用 4 字节（16 位段地址 + 16 位偏移地址）。
- 支持最多 256 个中断（编号 0 - 255）。例如：
	- 中断号 0 的服务程序地址存储在 0x0000 - 0x0003。
	- 中断号 1 的服务程序地址存储在 0x0004 - 0x0007。

#### 应用场景

- 设备驱动程序：管理外设的中断处理。
- 实时系统：快速响应时间敏感的事件。
- 多任务系统：协同调度多个中断源。

### 通道

在计算机系统中，通道（Channel）是一种用于协调数据传输的机制，特别是在主存储器与外部设备之间。根据不同的实现和应用场景，通道可以分为选择通道、DMA 专用通道、数组多路通道和字节多路通道。
- 例题：磁盘外部设备适合于连接数组多路通道或选择通道。

#### 选择通道（Selector Channel）

- 定义：选择通道是一种较为简单的通道，它一次只能为一个设备服务，完成一个设备的数据传输后再切换到下一个设备。
- 特点：
    - 每次只能连接一个设备，不能同时处理多个设备的数据请求。
    - 数据传输速率较高，适合高速设备（如磁盘驱动器）的数据传输。
    - 通道对设备的选择和管理相对简单。
- 适用场景：
    - 适用于高速外设的传输需求，如磁带机、硬盘驱动器等。

#### DMA 专用通道（DMA Dedicated Channel）

- 定义：DMA 专用通道是一种基于直接存储器访问（Direct Memory Access, DMA）的数据传输方式，设备通过 DMA 控制器直接访问主存储器。
- 特点：
    - 数据传输过程中无需 CPU 参与，减少了 CPU 的负担。
    - 支持突发模式传输，可以一次传输大量数据。
    - 每个 DMA 通道通常专用于一个外设，能够高效传输数据。
- 适用场景：
    - 用于高速数据传输设备，如硬盘、网络接口、图形处理器等。

#### 数组多路通道（Array Multiplex Channel）

- 定义：数组多路通道是能够为多个设备同时服务的通道类型，通过时间分片或循环方式在多个设备之间切换。
- 特点：
    - 通道可以轮流访问多个设备，每次处理一个设备的请求。
    - 通道的性能取决于设备的响应时间和通道切换的效率。
    - 多用于中速设备的数据传输。
- 适用场景：
    - 中等速率的外围设备，如键盘、鼠标、打印机等。

#### 字节多路通道（Byte Multiplex Channel）

- 定义：字节多路通道是一种为多个低速设备服务的通道类型，能够以字节为单位在多个设备之间切换。
- 特点：
    - 适用于处理速度较慢的设备，通道按需分配传输时间。
    - 能够同时连接多个设备，效率较高，但单设备的传输速率较低。
    - 采用时间分片技术，每个设备分配一个固定时间片。
- 适用场景：
    - 用于低速设备，如终端设备、串口、低速打印机等。

#### 对比总结

|类型|服务设备数|速度特点|适用设备|CPU 参与|
|---|---|---|---|---|
|选择通道|单设备|高速传输|磁盘、磁带|较少|
|DMA 专用通道|单设备|高速传输，CPU 负担低|硬盘、网络接口|不参与传输|
|数组多路通道|多设备|中速，设备轮流服务|中速设备|少量参与|
|字节多路通道|多设备|低速，按字节分配时间|低速终端、打印机|较少|

### 控制单元设计

#### 组合逻辑控制器（Hardwired Controller）

- 特点
	- 定义：通过硬件逻辑电路（如与门、或门、触发器等）直接实现指令的解码和控制信号生成。
	- 实现方式：指令的执行由一系列逻辑门和状态机完成。
	- 核心思想：根据指令的操作码，直接生成相应的控制信号。
- 优点
	1. 速度快：因为没有中间解释层，硬件直接生成控制信号，延迟低。
	2. 适合简单控制单元：对于简单的处理器设计（如 RISC 结构），硬件实现比较高效。
- 缺点
	1. 设计复杂性高：逻辑电路复杂，尤其是支持更多指令集时，硬件实现难度显著增加。
	2. 灵活性差：无法轻易修改或扩展指令集。
- 应用场景
	- 高性能处理器中，对速度要求较高的场景。
	- RISC 架构通常使用组合逻辑控制器。

#### 微程序控制器（Microprogrammed Controller）

- 特点
	- 定义：通过存储在控制存储器（Control Memory, CM）中的微程序，逐步生成控制信号。
	- 实现方式：
	    1. 每条指令对应一段微程序，微程序由一系列微指令组成。
	    2. 微指令存储在控制存储器中，微程序控制器通过读取微指令生成控制信号。
	- 核心思想：用微程序解释指令集，微程序本质上是一种固件。
- 优点
	1. 灵活性高：微程序存储在存储器中，支持修改和扩展指令集。
	2. 设计复杂度低：可以用系统化的方法设计复杂指令集。
	3. 支持复杂指令：适用于 CISC 结构的处理器。
- 缺点
	1. 速度较慢：由于需要从控制存储器中读取微指令，访问延迟增加。
	2. 存储开销大：需要存储大量的微指令。
- 应用场景
	- CISC 架构处理器（如早期的 Intel x86 处理器）。
	- 支持复杂指令集的处理器。

#### 存储逻辑控制器（Storage-Based Controller）

- 特点
	- 定义：依赖存储逻辑实现控制单元功能，将指令和控制信号的对应关系存储在查找表中。
	- 实现方式：
	    1. 通过一个存储单元（如 ROM 或 RAM），直接将指令映射到控制信号。
	    2. 指令解码后，直接从存储单元中查找对应的控制信号。
- 优点
	1. 实现简单：通过查找表快速生成控制信号。
	2. 灵活性高：可通过修改存储内容调整控制信号生成规则。
	3. 适合有限指令集：对于小规模的指令集，效率较高。
- 缺点
	1. 扩展性有限：随着指令集规模增加，存储单元开销显著增大。
	2. 速度依赖于存储性能：存储单元访问速度限制了控制信号生成速度。
- 应用场景
	- 小型处理器或嵌入式系统。
	- 特殊用途的控制单元。

#### 三者的对比

|特性|组合逻辑控制器|微程序控制器|存储逻辑控制器|
|---|---|---|---|
|实现复杂性|高|较低|低|
|速度|快|较慢|较慢|
|灵活性|差|高|较高|
|扩展性|差|高|较低|
|适用场景|RISC 处理器|CISC 处理器|嵌入式或小型处理器|

### 矩阵乘法器

- 矩阵乘法器（Matrix Multiplier）是一种用于实现矩阵乘法的硬件设备或电路。在计算机科学和数字系统设计中，矩阵乘法是一个非常常见且重要的运算，广泛应用于图形处理、科学计算、机器学习等领域。矩阵乘法器的目标是高效地计算两个矩阵的乘积，并将结果输出。
- 例题：按数据流的传递过程和控制节拍来看，阵列乘法器可认为是全并行运算的乘法器。
