---
layout: post
title: "复习日志：数据库系统"
categories: databases
tags: [databases, 国企]
math: true

---

## 基本概念

- 数据模型的三要素分别是数据结构、数据操作和完整性约束。数据模型能够描述数据库系统的静态结构特征、动态行为特征和完整性约束条件。
- 将数据库对象导出到另一数据库中，实现的功能是复制副本。
	- 将数据库对象（如表、视图、存储过程等）导出到另一数据库，实际上是创建这些对象的副本。
- 数据库技术的根本目标是要解决数据共享的问题。
- DBS（数据库系统）是一个更广泛的概念，它包含了 DB（数据库）和 DBMS（数据库管理系统）。
	- 数据库（DB）：指存储在计算机中的有组织的数据集合。
	- 数据库管理系统（DBMS）：是管理数据库的软件，用于创建、维护和操作数据库。
	- 数据库系统（DBS）：包括数据库（DB）、数据库管理系统（DBMS）以及相关的硬件、软件和人员。
- 数据库系统的核心是数据库管理系统。
- 数据库系统与文件系统的主要区别是文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决。
- 从计算机软件系统的构成来看，数据库管理系统是建立在操作系统之上的软件系统。
	- 操作系统负责计算机系统的进程管理、作业管理、存储器管理、设备管理、文件管理等，因此，数据库管理系统对数据的组织、管理和存取离不开操作系统的支持。
	- 数据库管理系统遇到创建和撤消进程、进程通信、读/写磁盘等要求时，必须请求操作系统的服务。
- 当前，在数据库管理系统的研究方面，较活跃的是演绎数据库。
- SQL Server 的身份验证模式包括 Windows 身份验证模式和混合验证模式。
- 数据库用户的账号一般由用户名和客户端主机组成。
- 数据库管理系统的恢复管理子系统保证了事务的持续性实现。
- 数据库实施的工作主要包括用 DDL 定义数据库结构、组织数据入库、编制与调试应用程序、数据库试运行。
- SQLServer 2008 支持的安装方式有无人值守安装、本地安装、远程安装。
- 数据库系统是一个综合的系统，而不仅仅是一个应用软件。
- 数据库重组织与重构造的差别在于：重组织并不修改原有的模式和内模式（数据的组织），而重构造会部分修改原有的模式和内模式（数据结构）。
- 一个内存变量在不同时刻可以具有不同的值和数据类型。

## 关系模型

- 数据库技术的奠基人之一 E. F. Codd 从 1970 年起发表过多篇论文，主要论述的是关系数据模型。
- 在关系数据模型中，用来表示实体的是二维表。
- 目前最常用的数据模型有层次模型、网状模型和关系模型。其中，层次模型和网状模型统称非关系模型。

### 关系运算

- 投影：对一个关系进行列选择。
- 选择：对一个关系进行行选择。
- 五种基本关系代数运算是：选择 $\sigma$，投影 $\pi$，并 $\cup$，差 $-$，笛卡尔积 $\times$。
- 关系演算语言包括元组关系演算和域关系演算，它们是基于逻辑表达的查询语言。
- 关系代数和关系演算的表达能力是等价的，即关系代数能够表示的查询，关系演算也能表示，反之亦然。它们都是关系数据库理论中的查询语言，具有相同的表达能力。但是，关系代数是过程性语言（描述如何计算结果），而关系演算是非过程性语言（描述结果的性质）。
- 在关系代数中，从两个关系的笛卡尔积中选取它们属性间满足一定条件的元组的操作称为连接。
- 例题：设有一个关系：职工（职工号，姓名，年龄，技能）。假设职工号唯一，每个职工有多项技能，则职工表的主码是（职工号，技能）。
- 若 $X\rightarrow Y$，且存在 $X$ 的真子集 $X'$，$X'\rightarrow Y$，则称 $Y$ 对 $X$ 部分函数依赖。
- 关系操作
	- 关系操作是用对关系的运算来表达查询要求的方式。
	- 关系操作的对象和结果都是集合。
	- 关系操作的能力可以通过代数方式和逻辑方式来表示。
	- 关系操作通过关系语言实现，关系语言的特点是高度非过程化。
- 属性之间的联系主要是根据属性的值域定义来确定的，函数依赖关系并不能决定属性之间的联系。
	- 例题：当属性 B 函数依赖于属性 A 时，属性 A 与 B 的联系是无法确定。
- 在同一个关系中不能有完全相同的两个元组，因为若存在两个完全相同的元组会违背实体完整性约束。
- 属性的取值范围称为属性的域。

### 范式

数据库设计中的范式（Normalization）是一组规则，用于减少数据冗余、提高数据一致性，并优化数据库结构。常见的范式包括第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯 - 科德范式（BCNF）、第四范式（4NF）和第五范式（5NF）。

- 关系数据库必须满足第一范式的要求，且所有数据必须转换为简单类型，如整数、浮点数和字符串。由于关系数据库不直接支持复杂的数据类型，因此大多关系数据库已经广泛应用于数据类型相对简单的商业领域，而在工业领域应用较少。
- 例题：定义学生关系模式 `S(S#, Sn, Sa，Sd, Dc)`（其属性分别为学号、姓名、年龄、所在系、所在系的系主任），则该关系为第二范式。
- 例题：关系模型中的关系模式至少应该是 1NF。
- 例题：设有关系模式 `A(S, C, M)`，其中各属性的含义：S 表示学生，C 表示课程，M 表示名次。其语义：每一个学生选修每门课程的成绩有一个确定的名次，每门课程中每一名次只有一个学生（没有并列名次）。关系模式 A 最高达到 BCNF。

#### 第一范式（1NF）

- 定义：确保每一列都是原子性的，即每一列都不可再分。
- 要求：
	- 表中的每一列都是不可分割的基本数据项。
	- 每一行都是唯一的（通常通过主键实现）。
- 示例：
	- 非 1NF：`订单表` 中有一列 `商品` 存储多个商品名称（如“商品 A, 商品 B”）。
	- 1NF：将 `商品` 列拆分为多行，每行只存储一个商品。

#### 第二范式（2NF）

- 定义：在 1NF 的基础上，消除非主属性对主键的部分函数依赖。
- 要求：
	- 表必须满足 1NF。
	- 所有非主属性必须完全依赖于主键（不能仅依赖于主键的一部分）。
- 示例：
	- 非 2NF：`订单明细表` 中，主键是 `订单ID` 和 `商品ID`，但 `客户姓名` 仅依赖于 `订单ID`。
	- 2NF：将 `客户姓名` 移到 `订单表` 中，确保非主属性完全依赖于主键。

#### 第三范式（3NF）

- 定义：在 2NF 的基础上，消除非主属性对主键的传递函数依赖。
- 要求：
	- 表必须满足 2NF。
	- 非主属性不能依赖于其他非主属性（即不能有传递依赖）。
- 示例：
	- 非 3NF：`员工表` 中，`部门名称` 依赖于 `部门ID`，而 `部门ID` 又依赖于 `员工ID`。
	- 3NF：将 `部门名称` 移到 `部门表` 中，消除传递依赖。

#### 巴斯 - 科德范式（BCNF）

- 定义：在 3NF 的基础上，进一步消除主属性对主键的依赖。
- 要求：
	- 表必须满足 3NF。
	- 任何非平凡的函数依赖 `X → Y` （Y 函数依赖于 X）中，`X` 必须是超键（即 `X` 能唯一标识一行）。
- 示例：
	- 非 BCNF：`学生选课表` 中，`学生ID` 和 `课程ID` 是主键，但 `教师ID` 依赖于 `课程ID`。
	- BCNF：将 `教师ID` 和 `课程ID` 移到单独的表中。

#### 第四范式（4NF）

- 定义：在 BCNF 的基础上，消除多值依赖。
- 要求：
	- 表必须满足 BCNF。
	- 如果存在多值依赖 `X →→ Y`，则 `X` 必须是超键。
- 示例：
	- 非 4NF：`学生表` 中，`学生ID` 对应多个 `课程ID` 和多个 `爱好`。
	- 4NF：将 `课程ID` 和 `爱好` 拆分为两个独立的表。

#### 第五范式（5NF）

- 定义：在 4NF 的基础上，消除连接依赖。
- 要求：
	- 表必须满足 4NF。
	- 表不能被进一步分解为更小的表而不丢失信息。
- 示例：
	- 非 5NF：`供应商-零件-项目表` 中，存在复杂的连接依赖。
	- 5NF：将表分解为多个更小的表，确保信息不丢失。

#### 总结

- 1NF：确保原子性。
- 2NF：消除部分依赖。（消除非主属性对码的部分函数依赖。）
- 3NF：消除传递依赖。（消除非主属性对码的传递函数依赖。）
- BCNF：强化 3NF，消除主属性依赖。（消除主属性对码的部分和传递函数依赖。）
- 4NF：消除多值依赖。（消除非平凡且非函数依赖的多值依赖。）
- 5NF：消除连接依赖。（消除不是由候选码所蕴含的连接依赖。）

在实际应用中，通常设计到 3NF 或 BCNF 即可满足大多数需求，更高的范式可能会增加复杂性，需根据具体场景权衡。

## 数据库设计

- 数据库应用系统设计的主要阶段包括：
	1. 需求分析：明确需求。
		- 数据库应用系统设计的需求分析阶段生成的文档是数据字典和数据流图。
		- 数据流图是描述系统数据流程的工具，适用于需求分析阶段。它将数据独立抽象出来，通过图形方式描述信息的来龙去脉和实际流程。
	2. 概念结构设计：设计 E-R 模型。
	3. 逻辑结构设计：设计表结构。
		- 从 E-R 图向数据模型转换。
		- 逻辑设计阶段必须要有数据库管理系统的支持。
	4. 物理设计：设计存储结构。
	5. 实现：创建数据库和应用系统。
	6. 测试：验证功能和性能。
	7. 部署与维护：上线并维护系统。
- 设计概念结构时，通常使用的方法有自顶向下、自底向上、逐步扩张和混合策略。
	- 自顶向下：从全局出发，逐步细化到局部。
	- 自底向上：从局部出发，逐步整合到全局。
	- 逐步扩张：从核心需求出发，逐步扩展功能。
	- 混合策略：结合自顶向下和自底向上的方法。
- 由于关系模式设计不当所引起的删除异常指的是不该删除的数据被删除。
- 关系规范化中的插入异常是指应该插入的数据没插入。
- 完整性约束
	- 实体完整性约束规定关系的主码不能取空值。
	- 完整性约束条件作用的对象不仅包括列级和元组级，还包括表级和数据库级。
	- 完整性约束可以应用于静态数据（如数据类型）和动态数据（如事务过程中的数据一致性）。
	- 数据的完整性是指数据的正确性和相容性。
	- 数据库的完整性控制基于完整性约束条件进行。
- 在数据库中，产生数据不一致的根本原因是数据冗余。
	- 数据冗余指的是同一数据在数据库中多次存储。当数据冗余存在时，如果其中一个数据副本被修改，而其他副本没有同步更新，就会导致数据不一致。因此，数据冗余是导致数据不一致的根本原因。
- 基于关系数据库系统、以数据处理为主的传统数据库应用具有四个主要特点：
	1. 结构统一，有大量结构相似的数据项，每个数据项都具有相同的字节数。
	2. 面向记录，基本的数据项由固定长度的记录组成。
	3. 数据项小，每条记录都很短，很少超过几百个字节。
	4. 原子字段，一个记录内的各个字段都很短，并且是定长的，字段内部是无结构的，符合第一范式。
- 概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是实体 - 联系模型。
- 与数据库相关的安全性措施主要包括用户标识和鉴定、存取控制、定义视图、审计、数据加密。
- 一定不能进行分离数据库操作的有 用户正在使用的数据库和 Master 数据库。
	- 用户正在使用的数据库：不能分离，因为分离操作要求数据库不能被任何用户连接。
	- Master 数据库：不能分离，因为 Master 数据库是系统数据库，存储了 SQL Server 的元数据。
- 并发操作带来的数据不一致性包括丢失修改、不可重复读和读“脏”数据。
	- 丢失修改：多个事务同时修改同一数据，导致部分修改丢失。
- 例题：数据库管理员希望对数据库进行性能优化，下列操作中行之有效的方法有（BC）。
    - A. 将数据库涉及的所有文件单独放在一个分区上供用户访问。
    - B. 将数据库的数据库文件和日志文件分别放在不同的分区上。
    - C. 在数据库服务器上尽量不要安装其他无关服务。
    - D. 一个表中的数据元组过多时，将其划分为两个或多个表。
    - 解析：
	    - A. 将数据库涉及的所有文件单独放在一个分区上供用户访问：不一定有效，可能增加磁盘 I/O 竞争。
		- B. 将数据库的数据库文件和日志文件分别放在不同的分区上：有效，可以减少磁盘 I/O 竞争，提高性能。
		- C. 在数据库服务器上尽量不要安装其他无关服务：有效，可以减少资源竞争，提高数据库性能。
		- D. 一个表中的数据元组过多时，将其划分为两个或多个表：不一定有效，分区或分表需要根据具体场景设计，盲目分表可能增加查询复杂度。

### 三级模式

- 三级模式数据库系统的三级模式结构包括：外模式、概念模式和内模式。
- 例题：子模式就是外模式，描述数据库用户的数据视图，即局部逻辑结构。

#### 外模式（External Schema）

- 定义：外模式是用户或应用程序所看到的数据视图。
- 特点：
	- 是概念模式的子集，针对特定用户或应用程序的需求。
	- 不同用户可以有多个外模式，每个外模式描述一部分数据。
- 作用：
	- 提供数据的安全性和独立性，用户只能访问其外模式中定义的数据。
- 示例：
	- 学生管理系统中，学生只能看到自己的成绩，而教师可以看到所有学生的成绩。

#### 概念模式（Conceptual Schema）

- 定义：概念模式是数据库的整体逻辑结构，描述所有数据及其关系。
- 特点：
	- 是数据库设计的核心，与具体的应用程序无关。
	- 包含所有实体、属性、关系以及约束条件。
- 作用：
	- 提供数据的全局视图，是外模式和内模式之间的桥梁。
- 示例：
	- 学生管理系统的概念模式包括学生、课程、成绩等实体及其关系。

#### 内模式（Internal Schema）

- 定义：内模式描述数据库的物理存储结构和物理存取方法。
- 特点：
	- 与硬件和存储细节相关，是数据库的最底层表示。
	- 包括数据存储方式、索引结构、文件组织等。
- 作用：
	- 提供数据的物理存储细节，确保数据高效存取。
- 示例：
	- 数据存储在磁盘上的文件组织形式（如 B+ 树索引）。

### 两级映射

两级映射是实现数据独立性的关键机制，包括：外模式 - 概念模式映射和概念模式 - 内模式映射。
- 例题：要保证数据库的逻辑独立性，需要修改的是模式与外模式之间的映射。
- 例题：数据的逻辑独立性，是指当模式改变时，通过对外模式/模式映象的相应改变，可以保持外模式不变，从而应用程序也不必修改。

#### 外模式 - 概念模式映射

- 定义：描述外模式与概念模式之间的对应关系。
- 作用：
	- 当概念模式发生变化时，只需修改映射关系，而无需修改外模式或应用程序。
	- 实现数据的逻辑独立性。
- 示例：
	- 如果概念模式中的“学生姓名”字段改为“姓名”，只需调整映射关系，外模式和应用程序无需修改。

#### 概念模式 - 内模式映射

- 定义：描述概念模式与内模式之间的对应关系。
- 作用：
	- 当内模式发生变化时（如存储结构改变），只需修改映射关系，而无需修改概念模式或外模式。
	- 实现数据的物理独立性。
- 示例：
	- 如果数据存储从堆文件改为 B+ 树索引，只需调整映射关系，概念模式和外模式无需修改。

#### 总结

- 三级模式
	- 外模式：用户视图。
	- 概念模式：全局逻辑结构。
	- 内模式：物理存储结构。
- 两级映射：
	- 外模式 - 概念模式映射：实现逻辑独立性。
	- 概念模式 - 内模式映射：实现物理独立性。

通过三级模式和两级映射，数据库系统能够实现数据的逻辑独立性和物理独立性，从而提高数据库的灵活性、可维护性和安全性。

### 关系数据库

- 关系数据库表中行、列次序无关。
- 关系数据库是用二维表来表示实体之间的联系的。关系表中的每一行称作一个元组，每一列称作一个属性。
- 候选码是指关系中的某一属性组的值能唯一地标识一个元组，而其真子集则不行。候选码可以由一个或多个属性组成。
- 关系模型数据库管理系统中，关系是指数据模型符合满足一定条件的二维表格式。
- 在关系模型中，一个关系就是一张二维表，但不是任何一张二维表都表示一个关系，如嵌套表。

## SQL

- SQL 语言不仅包括数据查询语言（DQL）和数据操纵语言（DML），还包括数据定义语言（DDL）和数据控制语言（DCL）。
- SQL 语言主要用于数据库操作，不能直接用于可视化应用程序开发。
- SQL 语言可以通过命令行或图形界面与数据库进行交互。
- SQL 语言基于关系代数，但它是一种更高级的查询语言，包含更多功能。

### 表/视图

- SQL 语句中删除表的命令是 `drop table`。
- 视图能够对机密数据提供安全保护。使用 `with encryption`，可以对创建的视图中的文本进行加密。
- 定义视图包括创建视图和删除视图。
- 视图与查询语句的执行速度无关。
- 使用视图可以简化用户的操作，用户所做的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户不需要了解。
- 在建立唯一索引时，若有重复属性值出现，只存储重复出现元组的第一个元组。
- 基本表是本身独立存在的表，在 SQL 中一个关系就对应一个基本表。

### 记录

- 逻辑运算符的运算优先级在通常情况下要高于关系运算符，但是在有括号的情况下，要先对括号中的内容进行运算。
- 当查询结果为多个元组时，嵌入式 SQL 中采用游标机制来指示所取出元组的位置。
- SQL 语句中常见的查询计算函数包括统计记录数函数 COUNT、求和函数 SUM、求平均值函数 AVG、求最大值函数 MAX、求最小值函数 MIN。求绝对值函数 ABS 不属于查询计算函数
- 由于一个汉字占两个字符的位置，因此匹配一个汉字需要使用两个 `_`。
- `between … and …` 用于确定查找条件的范围，且包含边界值。
- SQL 语言的标准库函数 COUNT、SUM、AVG、MAX 和 MIN 等，不允许出现在 `group by … having` 子句中。
- `delete from …`：删除表中所有数据，但保留表结构。
- `truncate table …`：删除表中所有数据，且效率高于 `delete`。
- `drop table …`：删除整个表，包括表结构和数据。
- 两段锁协议规定：在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁，而且在释放一个封锁之后，事务不再获得任何其他封锁。即：
	- 扩展阶段：事务可以申请锁，但不能释放锁。
	- 收缩阶段：事务可以释放锁，但不能申请锁。
	- 例题：下列封锁违反两段锁协议的是（D）。
	    - A. `Slock A, Slock B, Xlock C, Unlock A, Unlock B, Unlock C`
	    - B. `Slock A, Slock B, Xlock C, Unlock C, Unlock B, Unlock A`
	    - C. `Slock A, Slock B, Xlock C, Unlock B, Unlock C, Unlock A`
	    - D. `Slock A, Unlock A, Slock B, Xlock C, Unlock B, Unlock C`
- 事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。可串行化的调度中，不一定所有事务都必须符合两段锁协议。
